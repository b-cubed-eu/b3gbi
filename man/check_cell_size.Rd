% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/check_cell_size.R
\name{check_cell_size}
\alias{check_cell_size}
\title{#' Adjusts cell size to be compatible with input resolution, output units, and level.
#'
#' @param resolution The resolution of the input data (e.g., "10km", "0.1degrees").
#' @param cell_size The desired cell size.
#' @param input_units The units of the input resolution ("km" or "degrees").
#' @param output_units The units of the desired cell size ("km" or "degrees").
#'                    Note: When "km" is specified, the result is actually returned in meters.
#' @param level The geographical level ("world", "continent", or other).
#' @param data Optional data frame containing 'xcoord' and 'ycoord' columns for determining reference latitude.
#' @param reference_latitude Optional manual reference latitude. Used only if data is not provided.
#' @param input_crs The CRS of the input data (EPSG code or proj4string).
#' @param output_crs The CRS of the output data (EPSG code or proj4string).
#'
#' @return A compatible cell size (in meters when output_units="km", or in degrees when output_units="degrees").
#'
#' @examples
#' # With data frame
#' df <- data.frame(xcoord = c(10.1, 10.2, 10.3), ycoord = c(55.1, 55.2, 55.3))
#' check_cell_size("10km", 15, "km", "degrees", "country", data = df)
#'
#' # Without data frame
#' check_cell_size("0.1degrees", 15, "degrees", "km", "continent")  # Returns result in meters
#' @noRd
check_cell_size <- function(resolution, cell_size, input_units, output_units, level,
data = NULL, reference_latitude = 0,
input_crs = ifelse(input_units == "degrees", 4326, 3857),
output_crs = ifelse(output_units == "degrees", 4326, 3857)) {}
\usage{
check_cell_size(cell_size, resolution, level)
}
\arguments{
\item{cell_size}{The desired cell size (numeric or NULL).}

\item{resolution}{The resolution of the data (e.g., "10km", "0.25degrees").}

\item{level}{The geographical level ("world", "continent", or other).}
}
\value{
A compatible cell size in meters (if resolution is in km) or degrees.
}
\description{
#' Adjusts cell size to be compatible with input resolution, output units, and level.
#'
#' @param resolution The resolution of the input data (e.g., "10km", "0.1degrees").
#' @param cell_size The desired cell size.
#' @param input_units The units of the input resolution ("km" or "degrees").
#' @param output_units The units of the desired cell size ("km" or "degrees").
#'                    Note: When "km" is specified, the result is actually returned in meters.
#' @param level The geographical level ("world", "continent", or other).
#' @param data Optional data frame containing 'xcoord' and 'ycoord' columns for determining reference latitude.
#' @param reference_latitude Optional manual reference latitude. Used only if data is not provided.
#' @param input_crs The CRS of the input data (EPSG code or proj4string).
#' @param output_crs The CRS of the output data (EPSG code or proj4string).
#'
#' @return A compatible cell size (in meters when output_units="km", or in degrees when output_units="degrees").
#'
#' @examples
#' # With data frame
#' df <- data.frame(xcoord = c(10.1, 10.2, 10.3), ycoord = c(55.1, 55.2, 55.3))
#' check_cell_size("10km", 15, "km", "degrees", "country", data = df)
#'
#' # Without data frame
#' check_cell_size("0.1degrees", 15, "degrees", "km", "continent")  # Returns result in meters
#' @noRd
check_cell_size <- function(resolution, cell_size, input_units, output_units, level,
data = NULL, reference_latitude = 0,
input_crs = ifelse(input_units == "degrees", 4326, 3857),
output_crs = ifelse(output_units == "degrees", 4326, 3857)) {
}
\section{Input validation}{
if (!requireNamespace("sf", quietly = TRUE)) {
stop("Package 'sf' is required for accurate coordinate transformations.")
}
}

\section{Extract resolution value}{
res_value <- as.numeric(stringr::str_extract(resolution, "^\link{0-9,.}{1,6}(?=\link{a-z})"))
if (is.na(res_value)) {
stop(paste("Could not extract numerical value from resolution:", resolution))
}
}

\section{Convert resolution to meters if in km}{
if (input_units == "km") {
res_value_meters <- res_value * 1000
}
}

\section{Determine reference latitude from data if provided}{
if (!is.null(data)) {
if (!all(c("xcoord", "ycoord") \%in\% colnames(data))) {
stop("Data frame must contain 'xcoord' and 'ycoord' columns.")
}

\if{html}{\out{<div class="sourceCode">}}\preformatted{# Calculate median latitude (more robust than mean)
reference_latitude <- stats::median(data$ycoord, na.rm = TRUE)

# Determine the extent of the data for scale-appropriate adjustments
lat_range <- max(data$ycoord, na.rm = TRUE) - min(data$ycoord, na.rm = TRUE)
lon_range <- max(data$xcoord, na.rm = TRUE) - min(data$xcoord, na.rm = TRUE)

# Determine data extent (small, medium, large)
data_extent <- "small"  # Default to small
if (lat_range > 20 || lon_range > 20) \{
  data_extent <- "large"  # Continental scale
\} else if (lat_range > 5 || lon_range > 5) \{
  data_extent <- "medium"  # Country scale
\}

# Log the automatically determined reference point
message(paste("Using reference latitude:", round(reference_latitude, 2),
              "degrees (based on data with", data_extent, "extent)"))
}\if{html}{\out{</div>}}

}
}

\section{Set default cell size based on level, data extent, and output units}{

}

\section{For large datasets, we'll sample multiple points for more accurate adjustment}{

}

\section{Check if cell_size is smaller than the converted resolution}{
if (cell_size < converted_res_value) {
# Report in km for readability
report_cell_size <- if (output_units == "km") cell_size / 1000 else cell_size
report_converted_res <- if (output_units == "km") converted_res_value / 1000 else converted_res_value
report_units <- if (output_units == "km") "km" else "degrees"

\if{html}{\out{<div class="sourceCode">}}\preformatted{warning(paste0("Cell size (", report_cell_size, " ", report_units,
               ") is smaller than the input resolution (",
               res_value, " ", input_units, ", which is approximately ",
               round(report_converted_res, 4), " ", report_units,
               "). Adjusting to match the input resolution."))
cell_size <- converted_res_value
}\if{html}{\out{</div>}}

}
}

\section{Ensure cell_size is a multiple of the converted resolution}{

}

\section{This ensures grid alignment}{
remainder <- cell_size \%\% converted_res_value
if (remainder > 1e-10) {
# Round to nearest multiple of converted_res_value
cell_size <- ceiling(cell_size / converted_res_value) * converted_res_value

\if{html}{\out{<div class="sourceCode">}}\preformatted{# Report in km for readability
report_cell_size <- if (output_units == "km") cell_size / 1000 else cell_size
report_units <- if (output_units == "km") "km" else "degrees"

message(paste0("Cell size adjusted to ", report_cell_size, " ", report_units,
               " to ensure compatibility with input resolution."))
}\if{html}{\out{</div>}}

}
}

\section{Round to reasonable precision based on units}{
if (output_units == "degrees") {
cell_size <- round(cell_size, 6)  # 6 decimal places for degrees
} else {
cell_size <- round(cell_size, 2)  # 2 decimal places for km
}

return(cell_size)
}
#' Adjusts cell size to be compatible with input resolution, output units, and level.
#'
#' @param resolution The resolution of the input data (e.g., "10km", "0.1degrees").
#' @param cell_size The desired cell size.
#' @param input_units The units of the input resolution ("km" or "degrees").
#' @param output_units The units of the desired cell size ("km" or "degrees").
#' @param level The geographical level ("world", "continent", or other).
#'
#' @return A compatible cell size, or throws an error if no compatible size is found.
#'
#' @examples
#' tryCatch({
#'   print(check_cell_size("10km", 15, "km", "km", "world")) # Returns adjusted cell size
#'   print(check_cell_size("0.1degrees", 0.15, "degrees", "degrees", "continent")) # Returns adjusted cell size
#'   print(check_cell_size("10km", 15, "km", "degrees", "country")) # Returns adjusted cell size
#' }, error = function(e) {
#'   print(e$message)
#' })
#' @noRd
check_cell_size <- function(resolution, cell_size, input_units, output_units, level) {
}

\section{Extract resolution value and units}{
res_value <- as.numeric(stringr::str_extract(resolution, "^\link{0-9,.}{1,6}(?=\link{a-z})"))
}

\section{Set default cell size based on level}{
if (is.null(cell_size)){
if (level \%in\% c("world", "continent")) {
if (output_units == "km"){
cell_size <- 100000
} else {
cell_size <- 1 # Default for world/continent in degrees
}
} else {
if (output_units == "km"){
cell_size <- 10000
} else {
cell_size <- 0.25 # Default for other levels in degrees
}
}
}
}

\section{Check if units are the same}{

}

\examples{
check_cell_size(10, "1km", "country")
check_cell_size(NULL, "0.25degrees", "world")
}
